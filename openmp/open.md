# OpenMP的介绍
## 常用概念
**1.什么是并发**
- 是指两个或多个事件在同一时间间隔内发生
- 实质是物理CPU在若干程序之间多路复用
- 并发性是对有限物理资源强制行使多用户共享以提高效率

**2.什么是并行**
- 是指两个或多个事件在同一时刻发生
- 在多个程序环境下，使得多个程序同一时刻可在不同CPU上执行

**3.并行计算概论**
- 是指同时使用多种计算资源解决计算问题的过程
- 是提高计算机系统计算速度和处理能力的一种有效手段
- 具有强大的数据计算和数据处理能力
- 种类
- - 时间上
- - 空间上

**4.进程**
- 广义概念： 是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位
- 狭义概念：进程是正在运行的程序的实例

**5.线程**
- 线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
- 线程是独立调度和分派的基本单位。一个进程可以有很多线程，每条线程并行执行不同的任务。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储。

**6.超线程**
- 超线程技术把多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。
- 超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作。
- 虽然采用超线程技术能够同时执行两个线程，当两个线程同时需要某个资源时，其中一个线程必须让出资源暂时挂起，直到这些资源空闲以后才能继续。
- 因此，超线程的性能并不等于两个CPU的性能。而且，超线程技术的CPU需要芯片组、操作系统和应用软件的支持，才能比较理想地发挥该项技术的优势。

**7.MPI和OpenMP**
- MPI主要针对粗粒度级别的并行，主要应用在分布式计算机上，即将任务分配给集群中所有计算机上。
- OpenMP主要针对细粒度的循环进行并行，即在循环中将每次循环分配给不同的线程去执行，主要应用于一台独立的服务器或计算机上。由于使用线程间共享内存的方式协调并行计算，它在多核／多CPU结构上的效率很高、内存开销小、编程语句简洁直观，因此编程容易、编译器实现也容易

## OpenMP
**概念**
是由主要的计算机硬件和软件厂商共同制定的一种面向共享内存的多CPU多线程并行编辑接口
**特点**
- 编程模型
OpenMP规范的核心是并行区域和并行共享结构。编程人员通过并行
共享指令实现程序结构块的并行化和向量化。
- 执行模式
OpenMP对部分循环可采用指令simd显式地实现向量化。在并行区域
采用的是线程的派生和缩并模式。
- 数据环境
OpenMP规定，在并行区域内，各个子线程拥有各自的私有变量，其
他线程不能访问。全部线程均可对共享变量进行读写操作。
- 线程同步
OpenMP主要利用共享结构后的隐式同步来避免数据竞争，利用指令
flush等显式同步来维护共享数据的一致性，利用taskwait、taskgroup实现任务的同步完成。
- 并行计算
采用指令task、taskwait、taskgroup、taskloop等实现非规则循
环和递归等的并行计算。
- 异构设备
利用指令target、task、taskwait等实现异构计算。

**OpenMP由编译指导语句，库函数，和环境变量三部分组成**
- 格式：#pragma omp</directive/>[clause[[,]clause]...]
- /directive/部分是编译指导语句的主要指令，用来指导多个CPU
共享任务或知道多个CPU同步
- clause部分是可选的子句，它给出了相应的指令函数，可以影响到编译指导语句的具体执行
>注意：换行符是必选项。位于被这个指令包围的结构块之前，表示这条编译指导语句的终止。

**常用指令**
编译指导语句以＃pragma omp开始，后边跟具体的功能指令。常用的指令如下：
parallel
用在一个结构块之前，表示这段代码将被多个线程并行执行；
for
用于for循环语句之前，表示将循环计算任务分配到多个线程中并行执行，以实现任务分担，但必须保证每次循环之间无数据相关性
sections
用在要被并行执行的代码段之前，用于实现多个结构块语句的任务分担，可并行执行的代码段各自用section指令标出（注意区分sections和section）
critical
用在一段代码临界区之前，保证每次只有一个OpenMP线程进入
single
用在并行域内，表示一段只被单个线程执行的代码
flush
保证各个OpenMP线程的数据影像的一致性
barrier
用于并行域内代码的线程同步，线程执行到barrier时要停下等待，直到所有线程都执行到barrier时才继续往下执行
**常用的子句**
private
指定一个或多个变量在每个线程中都有它自己的私有副本
shared
指定一个或多个变量为多个线程间的共享变量
default
用来指定并行域内的变量的使用方式，缺省是shared
firstprivate
指定一个或多个变量在每个线程都有它自己的私有副本，并且私有变量要在进入并行域或任务分担域时，继承主线程中的同名变量的值作为初值
lastprivate
是用来指定将线程中的一个或多个私有变量的值在并行处理结束后复制到主线程中的同名变量中，负责拷贝的线程是for或sections任务分担中的最后一个线程
reduction
用来指定一个或多个变量是私有的，并且在并行处理结束后这些变量要执行指定的归约运算，并将结果返回给主线程同名变量
copyin
用来指定一个threadprivate类型的变量需要用主线程同名变量进行初始化
> 在Linux系统中使用c/c++编译器时，要通过以下方式包含OpenMP头文件：
> /#include</omp.h>
> 该头文件是调用库中多种函数的应用编程接口。通过这个文件，编译器才能链接正确的库

**常用的库函数**
omp_in_parallel
判断当前是否在并行域中
omp_set_num_threads
设置后续并行域中的线程数量
omp_get_num_procs
返回计算系统中处理器的个数
omp_get_num_threads
返回当前并行域中的线程数
omp_get_thread_num
返回当前的线程号
omp_get_max_threads
返回当前并行域中可用的最大线程数
## 变量作用域
- 共享变量：所有线程共同共有的变量
- 私有变量：个别线程拥有的变量
**private子句**
- 语法格式：private（变量列表）
**shared子句**
- 语法格式：shared（变量列表）
**default子句**
- 语法格式：（shared|none）
**reduction**
- 语法格式：（运算符：变量列表）
## 示例
![alt text](<屏幕截图 2025-05-18 112141-1-1.png>)
